---
path: "/ru/neural-networks/roadmap"
date: "2020-03-26"
title: "Разные мысли о своей научной работе"
draft: true
published: 2021-10-13
lastModified: 2022-07-31
---

## Обзор понятия Дата Майнинг: определения, которыми мы пользуемся.

Данные перед кластеризацией нужно подготовить. Ведь чтобы запомнить какую-то вещь или найти ей место в своей картине мира, мы на какое-то время задумываемся. Алгоритмизовывать процесс произвольной подготовки еще никто не сумел.

Overfitting, переобучение - на обучающихся данных  не были выявлены закономерности, которые всплыли в тесте.

Извлечение информации - это скучная, почти ручная работа по обучению компьютера пониманию текстов в интернете - новостей - и структурирование всего объема данных. Грустно, что при этом естественный язык упоминается лишь как цель (приводить данные к ЕЯ), но это не означает разработку ЕЯ.

Дата Майнинг для игрушек. При конечном числе действий (крестики-нолики 3х3), там, где нет вариаций как в шахматах компьютер может за серию игр научиться выбирать хорошие стратегии для игры. В игре dots and boxes американский математик Elwyn Ralph Berlekamp применил одну теорему и показал, что в нее можно играть без обучения (возможно просто хитрая стратегия).

-> Для любознательных: изучить теорему и предложенную стратегию. Выдеть способ применения теории к игре.

На наборе данных нельзя найти взаимоотношения, закономерности - data dredging - возникает overfitting. Возможный вариант разрешения: разделить обучение на две части. На одной части найти связи, на втором проверить, что они реально существуют. Этот эффект лекго представить, если сравнивать на что похожи облака. Классификация облака зависит от воображения субъекта, но реальных связей в различных облаках нельзя выделить. Достаточно сменить субъекта и весь эксперимент посыпется.


## С чего начать? Часть 1: Мешаем бульон

Интеллектуальные системы не могут сами обучиться работать с новыми файлами, новым представлением данных. Почему системе нужно добавлять алгоритмы по тому, как работать с файлами. Может максимум, что система в праве потребовать, это описание структуры файла. Такое требование выглядит справедливым, потому что если сравнивать bmp и jpeg изображения, то на экране монитора человеческий глаз может их и не отличить. Но на программном уровне для jpeg инженеры придумали алгоритм компрессии (позволяющий сохранять место на диске по сравнению с bmp) и декомпресии (который недоступен человеческому взору, т.к. скрыт в программе или в библиотеке).

Думаю, что не существует человека, который мог бы понимать вещи вокруг него, но не знать ни одного языка. Один язык должен быть. А значит предметы, вещи, поступки - все описывается и существует только благодаря возможности описать их неким языком.

Значит логично вернуться к самой ранней фантазии об ИИ: это говорящая и понимающая консоль. Компьютер "живет" тем, что задает вопросы ("Кто я?", "Какого цвета небо?") и получает на них ответы, сам учится работать с файлами. Если ошибается - его можно поправить. Поправить, значит объяснить; чтобы объяснить, нужно сформулировать предложение. Предложение состоит из слов, которые в контексте несут некоторый смысл.

Важно найти место для уровней абстракции, которые подтвержденно существуют (слои нейронов), - пока придумал, что это уровни подсистем функциональной системы Анохина.

-> Для любознательных: ФС управляется эмоциями? Как ее программировать (нужен Хаскль или Лисп)?

И тогда ФС будет задавать проблемы, которые нужно решать. С обучением и классификацией будут работать нейронные сети. Возможно смешение их с байесовыми сетями, потому что нужно введение вероятностей при "логическом выводе". Электрические импульсы нейронов рассматриваем как вероятности вывода. (Разные сети могут совмещать некоторые участки, если величины дуг равны, просто отождествляя вершины - так мы получим метафоры или ассоциации).

-> Для любознательных: отождествление вершин это чисто математическая абстракция, которой нет подтверждения биологически.

В иностранной литературе было найдено описание интересного алгоритма CN2. Он реализует индуктивный вывод правил. Почти как ЕК только с фиксированием целевого признака (этот признак играет роль классификатора - т.е. разбиение на кластеры в данных уже задано). Этот частный случай ЕК к тому же был позднее разработан (опубликован, если точно), и они относятся друг к другу как нейронные сети с придуманной инженером структурой и самоорганизующиеся сети Кохонена (к примеру, SOM).


## Часть 2: Начнем с игр

Логическая игра с прыгающими накрывающими друг друга фишками стала идеей фикс. Сначала проба на Паскле, потом переписывание всех функций на Си, далее продумывание классов, и теперь игра предстает на Си++. Спустя года 3 несколько методов просто поражают своей логикой - а=1, "б" определяется в условном операторе, а потом используется условие (б-а)<0. Нужно быть не в себе, чтобы такое написать. Но в целом код продуман, хотя иерархия объектов, все еще страдает.

Идея экспериментов с ООП - создание framework'а для удобного написания новых логических игр. Вся программа разделяется на модули. Грубо говоря, это отдельно компилируемые файлы, но по сути это должны быть классы, вид которых определяется интерфейсами. Для draw и logic использование классов пока необосновано и в коде выглядит притянутым за уши. Проверка framework'а будет заключаться в изменении процесса игры. В игре фишки, лежащие на одной клетке, превышая некоторый лимит, перескакивают на соседние. Что если разлетание осуществить как некоторое приложение силы в контексте физического движка, который обсчитывает объекты игрового мира. Плюс к этому добавить наклон поля, возможность столкновения фишек в воздухе.

- **main** - главный файл, точка входа. Использую glut. Здесь описывается взаимодействие с юзером и используется класс для рисования окружения.
- **draw** - классы для рисования окружения (не объектов: рисование объектов входит в штатный метод render). Этот модуль нужен для отрисовывания объектов, которые будут взаимодействовать по описанной отдельно логике. Рендерим объекты, передаем изменения, вызванные main логической части, и получив изменения для объектов рендерим их заново.
- **logic** - логика взаимодействия объектов. Как ходит конь, когда игра начинается и когда она заканчивается, как ход переходит к другому игроку. Искусственный интеллект находится здесь же.
- **elements** - главные объекты в игре. Здесь лежит их иерархия, методы по взаимодействию с "пользовательским" типом. Рендер входит в классы объектов, хотя это спорная часть. Так как логичнее было бы рендер отдать draw модулю. Это возможно при переходе с класс.render() на draw.render(класс объект).


## Часть 3: Раскладываем по полочкам

Методы машинного обучения, основанные на логике и выводе, выглядят убедительно. Но есть философские рассуждения на тему что было первым. Это человек придумал математику и логику. А вот аксиомы теории множеств, способные быть фундаментом математики, всех теорем уже доказанных и еще нет, появились не сразу, а только в последствии разработки теории [Выготский]. Поэтому в данной части до логики мы не дойдем, но наметим неплохую систему.

Начнем рассужадть. Если нужно формализовать функциональные системы, то выберем ключевое слово - функциональные - и разберемся, что от этих функций нам нужно. Для систем логичнее рассматривать отображения, чтобы сразу учитывать несколько параметров.
Отображение из n в m
f(x)=y

Каково отображение функциональной системы пищеварения? Явно эти отображения задаваться не будут. Для неявного задания отображения на основе некоторого эмпирического набора есть хорошо разработанный метод аппроксимации функций - нейронные сети. Значит отображение для функциональной системы, которое может работать с параметрами ФС, у нас есть.

Задаем множество ФС, множество параметров (разные ФС могут иметь общие параметры), а далее задаем приоритеты "организма" или эмоции, задающие новые цели, для которых выбираются ФС, или задаем оптимальное состояние "организма" (гомеостаз), которое каждая ФС должна стремиться. Здесь все как в обучении с подкреплением: потребности организма детерменированы, их мы вшиваем в код программы - это наш врожденный код ДНК.

-> Для любознательных: известно что у животных есть иерархия потребностей, которые следуют строго по мере удовлетворения других. Может ли человек менять предпочтение потребностей и развивать новые потребности?

Например, мы играем в крестики-нолики. Наши возможные действия - это ставить определенные знаки (либо крестики, либо нолики). Кто нам запретит ставить не свой знак?

-> Продолжение текста в скором времени состоится


## Часть 3: Анализ изображений

Чтобы унифицировать задачу, связанную с изображениями их нужно свести из двухмерного случая к одномерному. Изображение рассматривается как прямоугольный участок пространства R^2, над которым в R^3 задана некоторая поверхность, отвечающая за использованные в изображении цвета вида 0хRRGGBB. Производная может быть использована для нахождения контуров (острые пики поверхности). Сведение к одномерному случаю - графику некоторой функции - это проведение сечений по целым координатам этого прямоугольника, а затем объединение этих сечений в кусочно заданную функцию. Сечения - это самое незамысловатое кодирование.

А что если изображение заархивировать, а работать с кодированным текстом - абракадаброй. Сведение к абракадабре как и разархивирование мы проводить можем, т.к. располагаем соответствующим ПО, но сможет ли ЕК найти в абракадабре закономерности. Не лучше, чем среди инвариантов по Хэммингу.

Под пресловутым алгоритмом "архивирования" рассмотривался метод главных компонент. Вычисления сводились к сингулярному разложению (произведение унитарных матриц на диагональную матрицу собственных значений. первая унитарная матрица будет трансформацией текущих данных в пространство меньшей размерности).

Текст лекции по нейроинформатике о сегментации изображений и всплывшие статьи в связи с новым термином "сегментация" дают новые перспективы с кодированием исходного изображения, подготавливая его к классификации. Если найти нейробиологические исследования, которые подтверждают, что человеческий мозг разбивает изображение на детали и для примитивов есть особые участки нейронов (группа нейронов, распознающая круг, угол, линию...), то возможно утверждать, что эта процедура перед классификацией стоит "отдельно от" и строго "до" применения ЕК или байесовской сети. (Также можно отойти от рассмотрения теорий Хокинса к CTBN.)

Сегментация должна определить места для работы нейронных сетей. Т.е. не просто выделить контур, но и проанализировать этот контур и разбить его на регионы, т.ч. будут выполнены свойства:
- однородность регионов (однородность цвета или текстуры)
- непохожесть соседних регионов
- гладкость границы региона
- маленькое количество мелких «дырок» внутри региона

Для сегментации будем находить точки максимальной кривизны у нашего контура. Для этого нужно задать кривую в термине уравнения в естественных координатах. Это уравнение даст экстермальные точки, по которым контур разобьется на прямые линии.
(Точка пересечения двух прямых вызовет проблемы с вычислением кривизны) [Дуда Р., Харт П. Распознавание образов и анализ сцен, 1976; Attneave - Some informational aspects of visual perception, 1954]

Далее берем нейронные сети и тренируем их под эти примитивы. Когда сети, работающей с кругами, попадается что-то острое она выдает ноль, как будто ничего на вход и не поступало. Этот же принцип можно встретить в сетях адаптивного резонанса - для каждого объекта и его копий с точностью до некоторого расстояния на втором слое создается новый нейрон.

От всех сетей собирается вектор - он идет классификатору. Взаимоотношения между отрезками представлять в виде графа, который будет искать примитивы, которые будут его вершинами. Значения понятны и конечны - это геометрические примитивы (отрезок, эллипс, дуга). Переменные изначально имеют связи, они заданы ребрами графа. Стоит уточнить важную деталь графа: он имеет иерархию, т.е. представляется объемным. Работа между уровнями - это масштаб или детализация или исключение шума.

Остается понять, как эти сети будут воспринимать изображение. Первая проблема - это масштаб. Часть того же круга, большого круга при крупном масштабе может казаться дугой или линией. При каких условиях программа поймет, что 8 - это два эллипса, а 4 - это три линии?

-> P.S. Много времени уходит на поиск толковой книги, в которой бы говорилось не ищи вечный двигатель, не доказывай теорему Ферма на одной странице.
