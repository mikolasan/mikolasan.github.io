{"componentChunkName":"component---src-templates-blog-template-js","path":"/linux/bootloaders","result":{"data":{"markdownRemark":{"html":"<h2 id=\"boot-process\" style=\"position:relative;\">Boot process<a href=\"#boot-process\" aria-label=\"boot process permalink\" class=\"with-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\">\n                <path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3\n                3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3\n                  9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64\n                  1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\">\n                </path>\n                </svg></a></h2>\n<p>Have you ever wondered how inefficient the boot process in our computers? It requires 3 different protocol implementations. But why?</p>\n<p>Let’s first review how the boot happens in a BIOS systems.</p>\n<ul>\n<li>The BIOS finds connected devices. Which means it knows about IDE and SATA protocols and how to find the Master Boot Record.</li>\n<li>In the MBR it finds the bootloader.</li>\n<li>Then GRUB finds a bootable drive and passes execution to the kernel.</li>\n<li>Kernel has modules where SATA/IDE protocols are implemented.</li>\n</ul>\n<p>A common thing in Linux world is GRUB. GRUB has modules that also understand SATA and IDE. And partition tables, and filesystems, and more. Funny part is that the order of drives in BIOS can be different than the order detected by GRUB. And BIOS and GRUB don’t know about each other. They are not designed to exchange information.</p>\n<h2 id=\"bootloader-is-minimalistic-os\" style=\"position:relative;\">Bootloader is minimalistic OS<a href=\"#bootloader-is-minimalistic-os\" aria-label=\"bootloader is minimalistic os permalink\" class=\"with-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\">\n                <path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3\n                3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3\n                  9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64\n                  1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\">\n                </path>\n                </svg></a></h2>\n<p>The minimal example of a <strong>simplest operating system</strong> is typically referred to as a \"bare-metal\" or \"bootloader\" operating system. It provides the basic functionality required to boot a computer and execute code. It typically consists of a small amount of code that initializes the hardware, sets up the CPU and memory, and then loads and executes a kernel or application program.</p>\n<p>One example of a bare-metal operating system is the Little Kernel (LK), which is an open-source operating system designed for embedded systems and mobile devices. Another example is the Bootboot bootloader, which is a minimal bootloader designed for x86-64 architecture and used for bootstrapping operating systems.</p>\n<p>It's important to note that while these bare-metal operating systems can provide the basic functionality required to boot a computer, they do not include many of the features that are typically associated with modern operating systems such as device drivers, memory management, and multi-tasking.</p>\n<h2 id=\"history-of-pe-file-format\" style=\"position:relative;\">History of PE File Format<a href=\"#history-of-pe-file-format\" aria-label=\"history of pe file format permalink\" class=\"with-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\">\n                <path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3\n                3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3\n                  9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64\n                  1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\">\n                </path>\n                </svg></a></h2>\n<p><em>by <a href=\"https://www.codeproject.com/Articles/5356568/PE-Format-Illustrated-Part-1\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">Mark Pelf</a></em></p>\n<p>PE stands for ‘Portable Executable” and the format is invented in the 1980s. The dominant format then was MZ MS-DOS format, which has a special marker at the beginning of file to identify itself, letters “MZ” which by the way are initials of Mark Zbikowski, one of the MS-DOS developers. PE format was about to target Window platform, and they preserved backward compatibility with MZ format (.exe files) and enabled PE format (.exe files) if accidentally run on MS-DOS to report “This program cannot be run in DOS mode”, which was an important issue for Microsoft at the time. Therefore, you will see still that PE format contains MS-DOS style header, meaning it starts with the magic letters “MZ” and also a DOS-Stub that prints that message. That part is unnecessary today but has become part of the standard.\nPE format originates from Unix COFF format.\nToday, PE format is extended to host .NET code.</p>","excerpt":"Boot process Have you ever wondered how inefficient the boot process in our computers? It requires 3 different protocol implementations. But…","tableOfContents":"<ul>\n<li><a href=\"#boot-process\">Boot process</a></li>\n<li><a href=\"#bootloader-is-minimalistic-os\">Bootloader is minimalistic OS</a></li>\n<li><a href=\"#history-of-pe-file-format\">History of PE File Format</a></li>\n</ul>","fields":{"socialcard":"gatsby-plugin-social-card/77481a6c-8285-5018-9028-4a3c8b268fe3.jpg"},"frontmatter":{"date":"June 14, 2023","published":"June 14, 2023","lastModified":"June 14, 2023","title":"Bootloaders","subtitle":null,"section":null,"draft":null,"developing":null,"buttonText":null,"buttonLink":null,"secondButtonText":null,"secondButtonLink":null,"featuredImage":null}}},"pageContext":{"showLikes":true,"absolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/bootloaders.md","url":"/linux/bootloaders","next":{"excerpt":"When I needed to build the latest plymouth for Ubuntu 18 I encountered a chain of problems preventing me doing it. But nothing is impossible…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/build-latest-meson-on-ubuntu-18.md","frontmatter":{"title":"Build latest meson on Ubuntu 18","date":"2023-06-15T00:00:00.000Z","topic":null,"article":null},"id":"0113e779-ce7a-5c09-af81-c16c2566ffb2"},"previous":{"excerpt":"Let’s make a hello-world type Linux kernel module. Get Linux kernel sources First we need to integrate a Makefile, such as hello.mk into the…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/linux-kernel-module-hello-world.md","frontmatter":{"title":"Linux kernel module","date":"2023-06-04T00:00:00.000Z","topic":null,"article":null},"id":"9f658b62-73e4-5bf2-8b98-1a30ca2f705c"},"recentArticles":[{"excerpt":"The time is now. So you are following the official path","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/lunar-vim.md","frontmatter":{"title":"Lunar Vim","date":"2025-07-12T00:00:00.000Z","topic":null,"article":null},"id":"96fd1359-d24f-593f-bfd5-c6ea877b7e1e"},{"excerpt":"Prologue When I changed my email with Asana, the service that I liked so much, I found it when I had trouble planning my day, forgiving…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/task-management-with-taskwarrior.md","frontmatter":{"title":"Task management with taskwarrior","date":"2025-06-19T00:00:00.000Z","topic":null,"article":null},"id":"d251091d-7777-5f57-a398-6317d95233da"},{"excerpt":"I called my pool 'dinosaur' and three datasets, you guessed it, triassic, jurassic, cretaceous Steps: Reference archwiki - zfs zfs handbook…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/encrypted-backup-with-zfs.md","frontmatter":{"title":"Encrypted backup with ZFS","date":"2025-06-10T00:00:00.000Z","topic":null,"article":null},"id":"a8cfe7c2-1870-5a4d-a4b6-a9e5cb56f73b"},{"excerpt":"I already got used to auto-starting services when they run with docker compose or docker stack, but I like it even more when the apps run…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/autostart-everything.md","frontmatter":{"title":"Autostart everything","date":"2025-05-26T00:00:00.000Z","topic":null,"article":null},"id":"7c1cd1ea-fc7f-558a-9576-5f5420866bad"},{"excerpt":"So this happened when I was working on a Go project and quite frequently compiled binaries for deployment in docker containers. I didn't pay…","fileAbsolutePath":"/home/runner/work/mikolasan.github.io/mikolasan.github.io/src/markdown/linux/clear-space.md","frontmatter":{"title":"Clear space on Linux","date":"2025-04-15T00:00:00.000Z","topic":null,"article":null},"id":"b3347ef2-f534-5c29-bc5e-0ed82ca4c7ee"}]}},"staticQueryHashes":["2961657013","447685113"],"slicesMap":{}}